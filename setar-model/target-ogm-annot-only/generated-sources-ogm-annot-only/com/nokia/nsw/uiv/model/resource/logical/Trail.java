// This source file was generated by Unified Inventory CodeGen, Please DO NOT modify this file.
package com.nokia.nsw.uiv.model.resource.logical;

import com.fasterxml.jackson.annotation.JsonFilter;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonView;
import com.nokia.nsw.uiv.constants.FeatureFlag;
import com.nokia.nsw.uiv.datatype.SchemaSpecification;
import com.nokia.nsw.uiv.exception.BadRequestException;
import com.nokia.nsw.uiv.exception.ModificationNotAllowedException;
import com.nokia.nsw.uiv.framework.context.UivSpringContextAware;
import com.nokia.nsw.uiv.jackson.UivJsonViews;
import com.nokia.nsw.uiv.model.resource.CONSUMES;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.validation.Valid;
import javax.xml.bind.annotation.XmlType;
import lombok.extern.slf4j.Slf4j;
import org.neo4j.ogm.annotation.NodeEntity;
import org.neo4j.ogm.annotation.Relationship;
import org.neo4j.ogm.annotation.Transient;

@JsonTypeInfo(
        use = JsonTypeInfo.Id.NAME,
        defaultImpl = com.nokia.nsw.uiv.model.resource.logical.Trail.class,
        include = JsonTypeInfo.As.EXISTING_PROPERTY,
        visible = true,
        property = "@type"
)
@JsonFilter("com.nokia.nsw.uiv.model.resource.logical.Trail")
@NodeEntity(
        label = "com.nokia.nsw.uiv.model.resource.logical.Trail"
)
@Slf4j
@XmlType(
        name = "com.nokia.nsw.uiv.model.resource.logical.Trail"
)
public class Trail extends Pipe {
    @JsonFilter("pipeUTILIZES")
    @Relationship(
            type = "UTILIZES",
            direction = "OUTGOING"
    )
    @ApiModelProperty(
            dataType = "java.lang.String",
            allowableValues = "[com.nokia.nsw.uiv.model.resource.logical.Pipe]"
    )
    protected Set<Pipe> pipeUTILIZES = new HashSet<>();

    @Relationship(
            type = "CONSUMES",
            direction = "OUTGOING"
    )
    @ApiModelProperty
    protected Set<CONSUMES> consumedPipe = new HashSet<>();

    @JsonView(UivJsonViews.TmfView.class)
    @Transient
    @Valid
    private SchemaSpecification trailSpecification;

    public void addPipeUTILIZES(Pipe element) {
        this.setAssocModified(true);
        this.pipeUTILIZES.add(element);
        if (null != element && (null == element.getTrailUTILIZES() || !element.getTrailUTILIZES().contains(this))) {
            this.set_type(this.get_type());
            if (null == element.getTrailUTILIZES()) {
                element.setTrailUTILIZES(new HashSet<>());
            }
            element.addTrailUTILIZES(this);
        }
    }

    public void removePipeUTILIZES(Pipe element) {
        this.setAssocModified(true);
        if (null != element && null != this.pipeUTILIZES  && this.pipeUTILIZES.remove(element) && null != element.getTrailUTILIZES() && element.getTrailUTILIZES().contains(this)) {
            element.getTrailUTILIZES().remove(this);
        }
    }

    public Set<Pipe> getPipeUTILIZES() {
        return this.pipeUTILIZES;
    }

    public void setPipeUTILIZES(Set<Pipe> pipeUTILIZES) {
        this.setAssocModified(true);
        if (null != this.pipeUTILIZES) {
            List<Pipe> toDelete = new ArrayList<>(this.pipeUTILIZES);
            boolean setToNull = null == pipeUTILIZES || pipeUTILIZES.isEmpty();
            if (!setToNull)  {
                toDelete.removeAll(pipeUTILIZES);
            }
            for (Pipe each : toDelete) {
                if (null != each.getTrailUTILIZES()) {
                    each.getTrailUTILIZES().remove(this);
                }
            }
        }
        this.pipeUTILIZES=pipeUTILIZES;
        if (null != pipeUTILIZES) {
            for (Pipe each: pipeUTILIZES) {
                if (null != each && (null == each.getTrailUTILIZES() || !each.getTrailUTILIZES().contains(this))) {
                    this.set_type(this.get_type());
                    if (null == each.getTrailUTILIZES()) {
                        each.setTrailUTILIZES(new HashSet<>());
                    }
                    each.addTrailUTILIZES(this);
                }
            }
        }
    }

    public void addConsumedPipe(CONSUMES element) throws BadRequestException {
        this.setAssocModified(true);
        if (null != element) {
            if (null == element.getPipe()) {
                log.error("Rich object of type \"CONSUMES\" should have the other node end (pipe) value set");
                throw new BadRequestException("Rich object of type \"CONSUMES\" should have the other node end (pipe) value set");
            }
            if (null == element.getTrail() || !element.getTrail().equals(this) || !this.consumedPipe.contains(element)) {
                this.set_type(this.get_type());
                element.setTrail(this);
                if (null == this.consumedPipe) {
                    this.consumedPipe = new HashSet<>();
                }
                this.consumedPipe.add(element);
                if (null == element.getPipe().getConsumingTrail()) {
                    element.getPipe().setConsumingTrail(new HashSet<>());
                }
                element.getPipe().getConsumingTrail().add(element);
            }
        }
    }

    public void removeConsumedPipe(CONSUMES element) {
        this.setAssocModified(true);
        if (null != element && null != this.consumedPipe && this.consumedPipe.remove(element) && null != element.getPipe()) {
            element.getPipe().removeConsumingTrail(element);
        }
    }

    public Set<CONSUMES> getConsumedPipe() {
        return this.consumedPipe;
    }

    public void setConsumedPipe(Set<CONSUMES> consumedPipe) throws BadRequestException {
        this.setAssocModified(true);
        if (null != this.consumedPipe) {
            List<CONSUMES> toDelete = new ArrayList<>(this.consumedPipe);
            boolean setToNull = null == consumedPipe || consumedPipe.isEmpty();
            if (!setToNull)  {
                toDelete.removeAll(consumedPipe);
            }
            for (CONSUMES each : toDelete) {
                if (null != each.getPipe() && null != each.getPipe().getConsumingTrail()) {
                    each.getPipe().removeConsumingTrail(each);
                }
            }
        }
        if (null != consumedPipe) {
            for (CONSUMES each: consumedPipe) {
                if (null != each) {
                    if (null == each.getPipe()) {
                        log.error("Rich object of type \"CONSUMES\" should have the other node end (pipe) value set");
                        throw new BadRequestException("Rich object of type \"CONSUMES\" should have the other node end (pipe) value set");
                    }
                    if (null == each.getTrail() || !each.getTrail().equals(this) || !this.consumedPipe.contains(each)) {
                        this.set_type(this.get_type());
                        each.setTrail(this);
                        if (null == this.consumedPipe) {
                            this.consumedPipe = new HashSet<>();
                        }
                        boolean ispresent = this.consumedPipe.stream().anyMatch(o -> o==each);
                        if (!ispresent) {
                            this.consumedPipe.add(each);
                        }
                        if (null == each.getPipe().getConsumingTrail()) {
                            each.getPipe().setConsumingTrail(new HashSet<>());
                        }
                        ispresent = each.getPipe().getConsumingTrail().stream().anyMatch(o -> o==each);
                        if (!ispresent) {
                            each.getPipe().getConsumingTrail().add(each);
                        }
                    }
                }
            }
        }
    }

    public SchemaSpecification getTrailSpecification() {
        FeatureFlag featureFlag = UivSpringContextAware.getApplicationContext().getBean(FeatureFlag.class);
        if (this.getKind() != null && Boolean.parseBoolean(featureFlag.getTmfEnabled())) {
            this.trailSpecification = new SchemaSpecification();
            this.trailSpecification.setId(this.getKind());
            this.trailSpecification.setName(this.getKind());
            this.trailSpecification.setReferredType(this.getKind());
            this.trailSpecification.setVersion(this.getSchemaVersion());
        }
        return this.trailSpecification;
    }

    public void setTrailSpecification(SchemaSpecification trailSpecification) throws
            ModificationNotAllowedException {
        FeatureFlag featureFlag = UivSpringContextAware.getApplicationContext().getBean(FeatureFlag.class);
        if (Boolean.parseBoolean(featureFlag.getTmfEnabled())) {
            if (null != trailSpecification && null != trailSpecification.getId()) {
                if(null == this.getKind()) {
                    this.setSpecification(trailSpecification);
                    this.setKind(trailSpecification.getId());
                }
                else if (!this.getKind().equals(trailSpecification.getId())) {
                    throw new ModificationNotAllowedException("trailSpecification modification not allowed");
                }
            }
            this.trailSpecification = trailSpecification;
        }
    }
}
