// This source file was generated by Unified Inventory CodeGen, Please DO NOT modify this file.
package com.nokia.nsw.uiv.model.resource.logical;

import com.fasterxml.jackson.annotation.JsonFilter;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.nokia.nsw.uiv.exception.BadRequestException;
import com.nokia.nsw.uiv.model.resource.CONSUMES;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.xml.bind.annotation.XmlType;
import lombok.extern.slf4j.Slf4j;
import org.neo4j.ogm.annotation.NodeEntity;
import org.neo4j.ogm.annotation.Relationship;

@JsonTypeInfo(
        use = JsonTypeInfo.Id.NAME,
        defaultImpl = com.nokia.nsw.uiv.model.resource.logical.Connection.class,
        include = JsonTypeInfo.As.EXISTING_PROPERTY,
        visible = true,
        property = "@type"
)
@JsonSubTypes({
        @JsonSubTypes.Type(value = com.nokia.nsw.uiv.model.resource.logical.Trail.class, name = "trail"),
        @JsonSubTypes.Type(value = com.nokia.nsw.uiv.model.resource.logical.Connection.class, name = "connection")
})
@JsonFilter("com.nokia.nsw.uiv.model.resource.logical.Pipe")
@NodeEntity(
        label = "com.nokia.nsw.uiv.model.resource.logical.Pipe"
)
@Slf4j
@XmlType(
        name = "com.nokia.nsw.uiv.model.resource.logical.Pipe"
)
public abstract class Pipe extends LogicalResource {
    @JsonFilter("ownedLogicalInterface")
    @Relationship(
            type = "OWNS",
            direction = "OUTGOING"
    )
    @ApiModelProperty(
            dataType = "java.lang.String",
            allowableValues = "[com.nokia.nsw.uiv.model.resource.logical.LogicalInterface]"
    )
    protected Set<LogicalInterface> ownedLogicalInterface = new HashSet<>();

    @JsonFilter("containing")
    @Relationship(
            type = "CONTAINS",
            direction = "INCOMING"
    )
    @ApiModelProperty(
            dataType = "java.lang.String",
            allowableValues = "{com.nokia.nsw.uiv.model.resource.logical.Pipe}"
    )
    protected Pipe containing;

    @JsonFilter("contained")
    @Relationship(
            type = "CONTAINS",
            direction = "OUTGOING"
    )
    @ApiModelProperty(
            dataType = "java.lang.String",
            allowableValues = "[com.nokia.nsw.uiv.model.resource.logical.Pipe]"
    )
    protected Set<Pipe> contained = new HashSet<>();

    @JsonFilter("trailUTILIZES")
    @Relationship(
            type = "UTILIZES",
            direction = "INCOMING"
    )
    @ApiModelProperty(
            dataType = "java.lang.String",
            allowableValues = "[com.nokia.nsw.uiv.model.resource.logical.Trail]"
    )
    protected Set<Trail> trailUTILIZES = new HashSet<>();

    @Relationship(
            type = "CONSUMES",
            direction = "INCOMING"
    )
    @ApiModelProperty
    protected Set<CONSUMES> consumingTrail = new HashSet<>();

    public void addOwnedLogicalInterface(LogicalInterface element) {
        this.setAssocModified(true);
        this.ownedLogicalInterface.add(element);
        if (null != element && (null == element.getOwningPipe() || !element.getOwningPipe().equals(this))) {
            this.set_type(this.get_type());
            element.setOwningPipe(this);
        }
    }

    public void removeOwnedLogicalInterface(LogicalInterface element) {
        this.setAssocModified(true);
        if (null != element && null != this.ownedLogicalInterface  && this.ownedLogicalInterface.remove(element) && null != element.getOwningPipe()) {
            element.setOwningPipe(null);
        }
    }

    public Set<LogicalInterface> getOwnedLogicalInterface() {
        return this.ownedLogicalInterface;
    }

    public void setOwnedLogicalInterface(Set<LogicalInterface> ownedLogicalInterface) {
        this.setAssocModified(true);
        if (null != this.ownedLogicalInterface) {
            List<LogicalInterface> toDelete = new ArrayList<>(this.ownedLogicalInterface);
            boolean setToNull = null == ownedLogicalInterface || ownedLogicalInterface.isEmpty();
            if (!setToNull)  {
                toDelete.removeAll(ownedLogicalInterface);
            }
            for (LogicalInterface each : toDelete) {
                each.setOwningPipe(null);
            }
        }
        this.ownedLogicalInterface=ownedLogicalInterface;
        if (null != ownedLogicalInterface) {
            for (LogicalInterface each: ownedLogicalInterface) {
                if (null != each && ( null == each.getOwningPipe() || !each.getOwningPipe().equals(this))) {
                    this.set_type(this.get_type());
                    each.setOwningPipe(this);
                }
            }
        }
    }

    public Pipe getContaining() {
        return this.containing;
    }

    public void setContaining(Pipe containing) {
        this.setAssocModified(true);
        if (null == containing && null != this.containing && null != this.containing.getContained()) {
            this.containing.getContained().remove(this);
        }
        this.containing=containing;
        if (null != containing && (null == containing.getContained() || !containing.getContained().contains(this))) {
            this.set_type(this.get_type());
            if (null == containing.getContained()) {
                containing.setContained(new HashSet<>());
            }
            containing.addContained(this);
        }
    }

    public void addContained(Pipe element) {
        this.setAssocModified(true);
        this.contained.add(element);
        if (null != element && (null == element.getContaining() || !element.getContaining().equals(this))) {
            this.set_type(this.get_type());
            element.setContaining(this);
        }
    }

    public void removeContained(Pipe element) {
        this.setAssocModified(true);
        if (null != element && null != this.contained  && this.contained.remove(element) && null != element.getContaining()) {
            element.setContaining(null);
        }
    }

    public Set<Pipe> getContained() {
        return this.contained;
    }

    public void setContained(Set<Pipe> contained) {
        this.setAssocModified(true);
        if (null != this.contained) {
            List<Pipe> toDelete = new ArrayList<>(this.contained);
            boolean setToNull = null == contained || contained.isEmpty();
            if (!setToNull)  {
                toDelete.removeAll(contained);
            }
            for (Pipe each : toDelete) {
                each.setContaining(null);
            }
        }
        this.contained=contained;
        if (null != contained) {
            for (Pipe each: contained) {
                if (null != each && ( null == each.getContaining() || !each.getContaining().equals(this))) {
                    this.set_type(this.get_type());
                    each.setContaining(this);
                }
            }
        }
    }

    public void addTrailUTILIZES(Trail element) {
        this.setAssocModified(true);
        this.trailUTILIZES.add(element);
        if (null != element && (null == element.getPipeUTILIZES() || !element.getPipeUTILIZES().contains(this))) {
            this.set_type(this.get_type());
            if (null == element.getPipeUTILIZES()) {
                element.setPipeUTILIZES(new HashSet<>());
            }
            element.addPipeUTILIZES(this);
        }
    }

    public void removeTrailUTILIZES(Trail element) {
        this.setAssocModified(true);
        if (null != element && null != this.trailUTILIZES  && this.trailUTILIZES.remove(element) && null != element.getPipeUTILIZES() && element.getPipeUTILIZES().contains(this)) {
            element.getPipeUTILIZES().remove(this);
        }
    }

    public Set<Trail> getTrailUTILIZES() {
        return this.trailUTILIZES;
    }

    public void setTrailUTILIZES(Set<Trail> trailUTILIZES) {
        this.setAssocModified(true);
        if (null != this.trailUTILIZES) {
            List<Trail> toDelete = new ArrayList<>(this.trailUTILIZES);
            boolean setToNull = null == trailUTILIZES || trailUTILIZES.isEmpty();
            if (!setToNull)  {
                toDelete.removeAll(trailUTILIZES);
            }
            for (Trail each : toDelete) {
                if (null != each.getPipeUTILIZES()) {
                    each.getPipeUTILIZES().remove(this);
                }
            }
        }
        this.trailUTILIZES=trailUTILIZES;
        if (null != trailUTILIZES) {
            for (Trail each: trailUTILIZES) {
                if (null != each && (null == each.getPipeUTILIZES() || !each.getPipeUTILIZES().contains(this))) {
                    this.set_type(this.get_type());
                    if (null == each.getPipeUTILIZES()) {
                        each.setPipeUTILIZES(new HashSet<>());
                    }
                    each.addPipeUTILIZES(this);
                }
            }
        }
    }

    public void addConsumingTrail(CONSUMES element) throws BadRequestException {
        this.setAssocModified(true);
        if (null != element) {
            if (null == element.getTrail()) {
                log.error("Rich object of type \"CONSUMES\" should have the other node end (trail) value set");
                throw new BadRequestException("Rich object of type \"CONSUMES\" should have the other node end (trail) value set");
            }
            if (null == element.getPipe() || !element.getPipe().equals(this) || !this.consumingTrail.contains(element)) {
                this.set_type(this.get_type());
                element.setPipe(this);
                if (null == this.consumingTrail) {
                    this.consumingTrail = new HashSet<>();
                }
                this.consumingTrail.add(element);
                if (null == element.getTrail().getConsumedPipe()) {
                    element.getTrail().setConsumedPipe(new HashSet<>());
                }
                element.getTrail().getConsumedPipe().add(element);
            }
        }
    }

    public void removeConsumingTrail(CONSUMES element) {
        this.setAssocModified(true);
        if (null != element && null != this.consumingTrail && this.consumingTrail.remove(element) && null != element.getTrail()) {
            element.getTrail().removeConsumedPipe(element);
        }
    }

    public Set<CONSUMES> getConsumingTrail() {
        return this.consumingTrail;
    }

    public void setConsumingTrail(Set<CONSUMES> consumingTrail) throws BadRequestException {
        this.setAssocModified(true);
        if (null != this.consumingTrail) {
            List<CONSUMES> toDelete = new ArrayList<>(this.consumingTrail);
            boolean setToNull = null == consumingTrail || consumingTrail.isEmpty();
            if (!setToNull)  {
                toDelete.removeAll(consumingTrail);
            }
            for (CONSUMES each : toDelete) {
                if (null != each.getTrail() && null != each.getTrail().getConsumedPipe()) {
                    each.getTrail().removeConsumedPipe(each);
                }
            }
        }
        if (null != consumingTrail) {
            for (CONSUMES each: consumingTrail) {
                if (null != each) {
                    if (null == each.getTrail()) {
                        log.error("Rich object of type \"CONSUMES\" should have the other node end (trail) value set");
                        throw new BadRequestException("Rich object of type \"CONSUMES\" should have the other node end (trail) value set");
                    }
                    if (null == each.getPipe() || !each.getPipe().equals(this) || !this.consumingTrail.contains(each)) {
                        this.set_type(this.get_type());
                        each.setPipe(this);
                        if (null == this.consumingTrail) {
                            this.consumingTrail = new HashSet<>();
                        }
                        boolean ispresent = this.consumingTrail.stream().anyMatch(o -> o==each);
                        if (!ispresent) {
                            this.consumingTrail.add(each);
                        }
                        if (null == each.getTrail().getConsumedPipe()) {
                            each.getTrail().setConsumedPipe(new HashSet<>());
                        }
                        ispresent = each.getTrail().getConsumedPipe().stream().anyMatch(o -> o==each);
                        if (!ispresent) {
                            each.getTrail().getConsumedPipe().add(each);
                        }
                    }
                }
            }
        }
    }
}
